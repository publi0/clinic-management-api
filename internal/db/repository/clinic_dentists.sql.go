// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clinic_dentists.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const countActiveClinicLinksByDentist = `-- name: CountActiveClinicLinksByDentist :one
SELECT COUNT(*)::bigint
FROM clinic_dentists
WHERE dentist_id = $1::uuid
  AND ended_at IS NULL
`

func (q *Queries) CountActiveClinicLinksByDentist(ctx context.Context, dentistID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveClinicLinksByDentist, dentistID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createClinicDentist = `-- name: CreateClinicDentist :one
INSERT INTO clinic_dentists (
    clinic_id,
    dentist_id,
    is_admin,
    is_legal_representative,
    started_at
) VALUES (
    $1::uuid,
    $2::uuid,
    $3,
    $4,
    $5
)
RETURNING clinic_id, dentist_id, is_admin, is_legal_representative, started_at, ended_at, created_at, updated_at
`

type CreateClinicDentistParams struct {
	ClinicID              string    `json:"clinic_id"`
	DentistID             string    `json:"dentist_id"`
	IsAdmin               bool      `json:"is_admin"`
	IsLegalRepresentative bool      `json:"is_legal_representative"`
	StartedAt             time.Time `json:"started_at"`
}

func (q *Queries) CreateClinicDentist(ctx context.Context, arg CreateClinicDentistParams) (ClinicDentist, error) {
	row := q.db.QueryRowContext(ctx, createClinicDentist,
		arg.ClinicID,
		arg.DentistID,
		arg.IsAdmin,
		arg.IsLegalRepresentative,
		arg.StartedAt,
	)
	var i ClinicDentist
	err := row.Scan(
		&i.ClinicID,
		&i.DentistID,
		&i.IsAdmin,
		&i.IsLegalRepresentative,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const endClinicDentist = `-- name: EndClinicDentist :execrows
UPDATE clinic_dentists
SET ended_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE clinic_id = $1::uuid
  AND dentist_id = $2::uuid
  AND ended_at IS NULL
`

type EndClinicDentistParams struct {
	ClinicID  string `json:"clinic_id"`
	DentistID string `json:"dentist_id"`
}

func (q *Queries) EndClinicDentist(ctx context.Context, arg EndClinicDentistParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, endClinicDentist, arg.ClinicID, arg.DentistID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const endClinicDentistsByClinic = `-- name: EndClinicDentistsByClinic :execrows
UPDATE clinic_dentists
SET ended_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE clinic_id = $1::uuid
  AND ended_at IS NULL
`

func (q *Queries) EndClinicDentistsByClinic(ctx context.Context, clinicID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, endClinicDentistsByClinic, clinicID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const endClinicDentistsByDentist = `-- name: EndClinicDentistsByDentist :execrows
UPDATE clinic_dentists
SET ended_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE dentist_id = $1::uuid
  AND ended_at IS NULL
`

func (q *Queries) EndClinicDentistsByDentist(ctx context.Context, dentistID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, endClinicDentistsByDentist, dentistID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getActiveClinicDentist = `-- name: GetActiveClinicDentist :one
SELECT clinic_id, dentist_id, is_admin, is_legal_representative, started_at, ended_at, created_at, updated_at
FROM clinic_dentists
WHERE clinic_id = $1::uuid
  AND dentist_id = $2::uuid
  AND ended_at IS NULL
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveClinicDentistParams struct {
	ClinicID  string `json:"clinic_id"`
	DentistID string `json:"dentist_id"`
}

func (q *Queries) GetActiveClinicDentist(ctx context.Context, arg GetActiveClinicDentistParams) (ClinicDentist, error) {
	row := q.db.QueryRowContext(ctx, getActiveClinicDentist, arg.ClinicID, arg.DentistID)
	var i ClinicDentist
	err := row.Scan(
		&i.ClinicID,
		&i.DentistID,
		&i.IsAdmin,
		&i.IsLegalRepresentative,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateClinicDentistRole = `-- name: UpdateClinicDentistRole :one
UPDATE clinic_dentists
SET
    is_admin = COALESCE($1, is_admin),
    is_legal_representative = COALESCE($2, is_legal_representative),
    updated_at = CURRENT_TIMESTAMP
WHERE clinic_id = $3::uuid
  AND dentist_id = $4::uuid
  AND ended_at IS NULL
RETURNING clinic_id, dentist_id, is_admin, is_legal_representative, started_at, ended_at, created_at, updated_at
`

type UpdateClinicDentistRoleParams struct {
	IsAdmin               sql.NullBool `json:"is_admin"`
	IsLegalRepresentative sql.NullBool `json:"is_legal_representative"`
	ClinicID              string       `json:"clinic_id"`
	DentistID             string       `json:"dentist_id"`
}

func (q *Queries) UpdateClinicDentistRole(ctx context.Context, arg UpdateClinicDentistRoleParams) (ClinicDentist, error) {
	row := q.db.QueryRowContext(ctx, updateClinicDentistRole,
		arg.IsAdmin,
		arg.IsLegalRepresentative,
		arg.ClinicID,
		arg.DentistID,
	)
	var i ClinicDentist
	err := row.Scan(
		&i.ClinicID,
		&i.DentistID,
		&i.IsAdmin,
		&i.IsLegalRepresentative,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
