// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dentists.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createDentist = `-- name: CreateDentist :one
INSERT INTO dentists (id, person_id)
VALUES ($1::uuid, $2::uuid)
RETURNING id, person_id, created_at, updated_at, deleted_at
`

type CreateDentistParams struct {
	ID       string `json:"id"`
	PersonID string `json:"person_id"`
}

func (q *Queries) CreateDentist(ctx context.Context, arg CreateDentistParams) (Dentist, error) {
	row := q.db.QueryRowContext(ctx, createDentist, arg.ID, arg.PersonID)
	var i Dentist
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteDentist = `-- name: DeleteDentist :execrows
UPDATE dentists
SET deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1::uuid
  AND deleted_at IS NULL
`

func (q *Queries) DeleteDentist(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteDentist, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getDentistByID = `-- name: GetDentistByID :one
SELECT id, person_id, created_at, updated_at, deleted_at
FROM dentists
WHERE id = $1::uuid
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetDentistByID(ctx context.Context, id string) (Dentist, error) {
	row := q.db.QueryRowContext(ctx, getDentistByID, id)
	var i Dentist
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDentistByPersonID = `-- name: GetDentistByPersonID :one
SELECT id, person_id, created_at, updated_at, deleted_at
FROM dentists
WHERE person_id = $1::uuid
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetDentistByPersonID(ctx context.Context, personID string) (Dentist, error) {
	row := q.db.QueryRowContext(ctx, getDentistByPersonID, personID)
	var i Dentist
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDentistDetailsByID = `-- name: GetDentistDetailsByID :one
SELECT
    d.id AS dentist_id,
    d.person_id,
    p.legal_name,
    p.tax_id_number,
    p.email,
    p.phone
FROM dentists d
JOIN people p ON p.id = d.person_id
WHERE d.id = $1::uuid
  AND d.deleted_at IS NULL
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetDentistDetailsByIDRow struct {
	DentistID   string         `json:"dentist_id"`
	PersonID    string         `json:"person_id"`
	LegalName   string         `json:"legal_name"`
	TaxIDNumber string         `json:"tax_id_number"`
	Email       sql.NullString `json:"email"`
	Phone       sql.NullString `json:"phone"`
}

func (q *Queries) GetDentistDetailsByID(ctx context.Context, id string) (GetDentistDetailsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getDentistDetailsByID, id)
	var i GetDentistDetailsByIDRow
	err := row.Scan(
		&i.DentistID,
		&i.PersonID,
		&i.LegalName,
		&i.TaxIDNumber,
		&i.Email,
		&i.Phone,
	)
	return i, err
}

const listDentistsByClinicID = `-- name: ListDentistsByClinicID :many
SELECT
    d.id AS dentist_id,
    d.person_id,
    p.legal_name,
    p.tax_id_number,
    p.email,
    p.phone,
    cd.is_admin,
    cd.is_legal_representative,
    cd.started_at,
    cd.ended_at
FROM clinic_dentists cd
JOIN dentists d ON d.id = cd.dentist_id
JOIN people p ON p.id = d.person_id
JOIN clinics c ON c.id = cd.clinic_id
WHERE cd.clinic_id = $1::uuid
  AND cd.ended_at IS NULL
  AND d.deleted_at IS NULL
  AND p.deleted_at IS NULL
  AND c.deleted_at IS NULL
ORDER BY d.id
`

type ListDentistsByClinicIDRow struct {
	DentistID             string         `json:"dentist_id"`
	PersonID              string         `json:"person_id"`
	LegalName             string         `json:"legal_name"`
	TaxIDNumber           string         `json:"tax_id_number"`
	Email                 sql.NullString `json:"email"`
	Phone                 sql.NullString `json:"phone"`
	IsAdmin               bool           `json:"is_admin"`
	IsLegalRepresentative bool           `json:"is_legal_representative"`
	StartedAt             time.Time      `json:"started_at"`
	EndedAt               sql.NullTime   `json:"ended_at"`
}

func (q *Queries) ListDentistsByClinicID(ctx context.Context, clinicID string) ([]ListDentistsByClinicIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listDentistsByClinicID, clinicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDentistsByClinicIDRow{}
	for rows.Next() {
		var i ListDentistsByClinicIDRow
		if err := rows.Scan(
			&i.DentistID,
			&i.PersonID,
			&i.LegalName,
			&i.TaxIDNumber,
			&i.Email,
			&i.Phone,
			&i.IsAdmin,
			&i.IsLegalRepresentative,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDentistsByClinicIDCursor = `-- name: ListDentistsByClinicIDCursor :many
SELECT
    d.id AS dentist_id,
    d.person_id,
    p.legal_name,
    p.tax_id_number,
    p.email,
    p.phone,
    cd.is_admin,
    cd.is_legal_representative,
    cd.started_at,
    cd.ended_at
FROM clinic_dentists cd
JOIN dentists d ON d.id = cd.dentist_id
JOIN people p ON p.id = d.person_id
JOIN clinics c ON c.id = cd.clinic_id
WHERE cd.clinic_id = $1::uuid
  AND cd.ended_at IS NULL
  AND d.deleted_at IS NULL
  AND p.deleted_at IS NULL
  AND c.deleted_at IS NULL
  AND ($2::uuid IS NULL OR d.id > $2::uuid)
ORDER BY d.id
LIMIT $3
`

type ListDentistsByClinicIDCursorParams struct {
	ClinicID       string        `json:"clinic_id"`
	AfterDentistID uuid.NullUUID `json:"after_dentist_id"`
	PageLimit      int32         `json:"page_limit"`
}

type ListDentistsByClinicIDCursorRow struct {
	DentistID             string         `json:"dentist_id"`
	PersonID              string         `json:"person_id"`
	LegalName             string         `json:"legal_name"`
	TaxIDNumber           string         `json:"tax_id_number"`
	Email                 sql.NullString `json:"email"`
	Phone                 sql.NullString `json:"phone"`
	IsAdmin               bool           `json:"is_admin"`
	IsLegalRepresentative bool           `json:"is_legal_representative"`
	StartedAt             time.Time      `json:"started_at"`
	EndedAt               sql.NullTime   `json:"ended_at"`
}

func (q *Queries) ListDentistsByClinicIDCursor(ctx context.Context, arg ListDentistsByClinicIDCursorParams) ([]ListDentistsByClinicIDCursorRow, error) {
	rows, err := q.db.QueryContext(ctx, listDentistsByClinicIDCursor, arg.ClinicID, arg.AfterDentistID, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDentistsByClinicIDCursorRow{}
	for rows.Next() {
		var i ListDentistsByClinicIDCursorRow
		if err := rows.Scan(
			&i.DentistID,
			&i.PersonID,
			&i.LegalName,
			&i.TaxIDNumber,
			&i.Email,
			&i.Phone,
			&i.IsAdmin,
			&i.IsLegalRepresentative,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDentistsByClinicIDs = `-- name: ListDentistsByClinicIDs :many
SELECT
    cd.clinic_id,
    d.id AS dentist_id,
    d.person_id,
    p.legal_name,
    p.tax_id_number,
    p.email,
    p.phone,
    cd.is_admin,
    cd.is_legal_representative,
    cd.started_at,
    cd.ended_at
FROM clinic_dentists cd
JOIN dentists d ON d.id = cd.dentist_id
JOIN people p ON p.id = d.person_id
JOIN clinics c ON c.id = cd.clinic_id
WHERE cd.clinic_id = ANY($1::uuid[])
  AND cd.ended_at IS NULL
  AND d.deleted_at IS NULL
  AND p.deleted_at IS NULL
  AND c.deleted_at IS NULL
ORDER BY cd.clinic_id, d.id
`

type ListDentistsByClinicIDsRow struct {
	ClinicID              string         `json:"clinic_id"`
	DentistID             string         `json:"dentist_id"`
	PersonID              string         `json:"person_id"`
	LegalName             string         `json:"legal_name"`
	TaxIDNumber           string         `json:"tax_id_number"`
	Email                 sql.NullString `json:"email"`
	Phone                 sql.NullString `json:"phone"`
	IsAdmin               bool           `json:"is_admin"`
	IsLegalRepresentative bool           `json:"is_legal_representative"`
	StartedAt             time.Time      `json:"started_at"`
	EndedAt               sql.NullTime   `json:"ended_at"`
}

func (q *Queries) ListDentistsByClinicIDs(ctx context.Context, clinicIds []string) ([]ListDentistsByClinicIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDentistsByClinicIDs, pq.Array(clinicIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDentistsByClinicIDsRow{}
	for rows.Next() {
		var i ListDentistsByClinicIDsRow
		if err := rows.Scan(
			&i.ClinicID,
			&i.DentistID,
			&i.PersonID,
			&i.LegalName,
			&i.TaxIDNumber,
			&i.Email,
			&i.Phone,
			&i.IsAdmin,
			&i.IsLegalRepresentative,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
