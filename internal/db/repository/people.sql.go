// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: people.sql

package repository

import (
	"context"
	"database/sql"
)

const createPerson = `-- name: CreatePerson :one
INSERT INTO people (
    id,
    person_type,
    tax_id_type,
    tax_id_number,
    legal_name,
    trade_name,
    email,
    phone
) VALUES (
    $1::uuid,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING id, person_type, tax_id_type, tax_id_number, legal_name, trade_name, email, phone, created_at, updated_at, deleted_at
`

type CreatePersonParams struct {
	ID          string         `json:"id"`
	PersonType  string         `json:"person_type"`
	TaxIDType   string         `json:"tax_id_type"`
	TaxIDNumber string         `json:"tax_id_number"`
	LegalName   string         `json:"legal_name"`
	TradeName   sql.NullString `json:"trade_name"`
	Email       sql.NullString `json:"email"`
	Phone       sql.NullString `json:"phone"`
}

func (q *Queries) CreatePerson(ctx context.Context, arg CreatePersonParams) (Person, error) {
	row := q.db.QueryRowContext(ctx, createPerson,
		arg.ID,
		arg.PersonType,
		arg.TaxIDType,
		arg.TaxIDNumber,
		arg.LegalName,
		arg.TradeName,
		arg.Email,
		arg.Phone,
	)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.PersonType,
		&i.TaxIDType,
		&i.TaxIDNumber,
		&i.LegalName,
		&i.TradeName,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deletePerson = `-- name: DeletePerson :execrows
UPDATE people
SET deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1::uuid
  AND deleted_at IS NULL
`

func (q *Queries) DeletePerson(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePerson, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getPersonByTaxID = `-- name: GetPersonByTaxID :one
SELECT id, person_type, tax_id_type, tax_id_number, legal_name, trade_name, email, phone, created_at, updated_at, deleted_at
FROM people
WHERE tax_id_number = $1
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetPersonByTaxID(ctx context.Context, taxIDNumber string) (Person, error) {
	row := q.db.QueryRowContext(ctx, getPersonByTaxID, taxIDNumber)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.PersonType,
		&i.TaxIDType,
		&i.TaxIDNumber,
		&i.LegalName,
		&i.TradeName,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePerson = `-- name: UpdatePerson :one
UPDATE people
SET
    legal_name = COALESCE($1, legal_name),
    trade_name = COALESCE($2, trade_name),
    email = COALESCE($3, email),
    phone = COALESCE($4, phone),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $5::uuid
  AND deleted_at IS NULL
RETURNING id, person_type, tax_id_type, tax_id_number, legal_name, trade_name, email, phone, created_at, updated_at, deleted_at
`

type UpdatePersonParams struct {
	LegalName sql.NullString `json:"legal_name"`
	TradeName sql.NullString `json:"trade_name"`
	Email     sql.NullString `json:"email"`
	Phone     sql.NullString `json:"phone"`
	ID        string         `json:"id"`
}

func (q *Queries) UpdatePerson(ctx context.Context, arg UpdatePersonParams) (Person, error) {
	row := q.db.QueryRowContext(ctx, updatePerson,
		arg.LegalName,
		arg.TradeName,
		arg.Email,
		arg.Phone,
		arg.ID,
	)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.PersonType,
		&i.TaxIDType,
		&i.TaxIDNumber,
		&i.LegalName,
		&i.TradeName,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
