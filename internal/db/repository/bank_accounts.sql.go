// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bank_accounts.sql

package repository

import (
	"context"
)

const createBankAccount = `-- name: CreateBankAccount :one
INSERT INTO bank_accounts (
    id,
    clinic_id,
    bank_code,
    branch_number,
    account_number
) VALUES (
    $1::uuid,
    $2::uuid,
    $3,
    $4,
    $5
)
RETURNING id, clinic_id, bank_code, branch_number, account_number, created_at, updated_at, deleted_at
`

type CreateBankAccountParams struct {
	ID            string `json:"id"`
	ClinicID      string `json:"clinic_id"`
	BankCode      string `json:"bank_code"`
	BranchNumber  string `json:"branch_number"`
	AccountNumber string `json:"account_number"`
}

func (q *Queries) CreateBankAccount(ctx context.Context, arg CreateBankAccountParams) (BankAccount, error) {
	row := q.db.QueryRowContext(ctx, createBankAccount,
		arg.ID,
		arg.ClinicID,
		arg.BankCode,
		arg.BranchNumber,
		arg.AccountNumber,
	)
	var i BankAccount
	err := row.Scan(
		&i.ID,
		&i.ClinicID,
		&i.BankCode,
		&i.BranchNumber,
		&i.AccountNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteBankAccountByIDAndClinicID = `-- name: DeleteBankAccountByIDAndClinicID :execrows
UPDATE bank_accounts
SET deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1::uuid
  AND clinic_id = $2::uuid
  AND deleted_at IS NULL
`

type DeleteBankAccountByIDAndClinicIDParams struct {
	ID       string `json:"id"`
	ClinicID string `json:"clinic_id"`
}

func (q *Queries) DeleteBankAccountByIDAndClinicID(ctx context.Context, arg DeleteBankAccountByIDAndClinicIDParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteBankAccountByIDAndClinicID, arg.ID, arg.ClinicID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getBankAccountByIDAndClinicID = `-- name: GetBankAccountByIDAndClinicID :one
SELECT id, clinic_id, bank_code, branch_number, account_number, created_at, updated_at, deleted_at
FROM bank_accounts
WHERE id = $1::uuid
  AND clinic_id = $2::uuid
  AND deleted_at IS NULL
LIMIT 1
`

type GetBankAccountByIDAndClinicIDParams struct {
	ID       string `json:"id"`
	ClinicID string `json:"clinic_id"`
}

func (q *Queries) GetBankAccountByIDAndClinicID(ctx context.Context, arg GetBankAccountByIDAndClinicIDParams) (BankAccount, error) {
	row := q.db.QueryRowContext(ctx, getBankAccountByIDAndClinicID, arg.ID, arg.ClinicID)
	var i BankAccount
	err := row.Scan(
		&i.ID,
		&i.ClinicID,
		&i.BankCode,
		&i.BranchNumber,
		&i.AccountNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listBankAccountsByClinicID = `-- name: ListBankAccountsByClinicID :many
SELECT id, clinic_id, bank_code, branch_number, account_number, created_at, updated_at, deleted_at
FROM bank_accounts
WHERE clinic_id = $1::uuid
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListBankAccountsByClinicID(ctx context.Context, clinicID string) ([]BankAccount, error) {
	rows, err := q.db.QueryContext(ctx, listBankAccountsByClinicID, clinicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BankAccount{}
	for rows.Next() {
		var i BankAccount
		if err := rows.Scan(
			&i.ID,
			&i.ClinicID,
			&i.BankCode,
			&i.BranchNumber,
			&i.AccountNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
